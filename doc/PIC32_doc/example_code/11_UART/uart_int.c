#include "NU32.h"              // constants, functions for startup and UART

void __ISR(_UART_3_VECTOR, IPL1SOFT) IntUart1Handler(void) {
  if (IFS1bits.U3RXIF) {       // check if interrupt generated by a RX event
    U3TXREG = U3RXREG;         // send the received data out
    IFS1bits.U3RXIF = 0;       // clear the RX interrupt flag
  } else if(IFS1bits.U3TXIF) { // if it is a TX interrupt 
  } else if(IFS1bits.U3EIF) {  // if it is an error interrupt. check U3STA for reason
  } 
}

int main(void) {
  NU32_Startup();   // cache on, interrupts on, LED/button init, UART init
  NU32_LED1 = 1;
  NU32_LED2 = 1;
  __builtin_disable_interrupts();

  // set baud to 230400, to match terminal emulator; use default 8N1 of UART
  U3MODEbits.BRGH = 0; 
  U3BRG = ((NU32_SYS_FREQ / 230400) / 16) - 1;

  // configure TX & RX pins 
  U3STAbits.UTXEN = 1;
  U3STAbits.URXEN = 1;
  
  // configure using RTS and CTS
  U3MODEbits.UEN = 2;

  // configure the UART interrupts
  U3STAbits.URXISEL = 0x0; // RX interrupt when receive buffer not empty
  IFS1bits.U3RXIF = 0;     // clear the rx interrupt flag.  for 
                           // tx or error interrupts you would also need to clear
                           // the respective flags
  IPC7bits.U3IP = 1;       // interrupt priority
  IEC1bits.U3RXIE = 1;     // enable the RX interrupt

  // turn on UART1
  U3MODEbits.ON = 1;      
  __builtin_enable_interrupts();
  while(1) {
    ;
  }
  return 0;
}
